Script started on 2019-11-12 23:31:11-0500
]0;mjs96@gold28: ~/cs112/project08[01;32mmjs96@gold28[00m:[01;34m~/cs112/project08[00m$ ls
ArrayQueue.cpp        drawnOnward.txt       PalindromeTester.h  Stack.h
ArrayQueue.h          Exception.h           pTestIn.txt         StackTester.cpp
ArrayQueueTester.cpp  Palindrome.cpp        pTestOut.txt        StackTester.h
ArrayQueueTester.h    Palindrome.h          QueueException.h    tester.cpp
[0m[01;34mDebug[0m                 PalindromeTester.cpp  StackException.h    typescript
]0;mjs96@gold28: ~/cs112/project08[01;32mmjs96@gold28[00m:[01;34m~/cs112/project08[00m$ cat ArrayQueue.h ArrayQueue.cpp ArrayQueueTester..h ArrayQueueTester.cpp QueueException.h Stack.h StackTester.h StackTester.cpp SttackException.h Palindrome.h Palindrome.cpp PalindromeTester.h PalindromeTester.ccpp tester.cpp pTestIn.txt pTestOut.txt drawnOnward.txt 
/* ArrayQueue.h declares a Queue class using a dynamic array.
 * Begun by: Joel Adams, for CS 112 at Calvin University.
 * Student name:
 * Date:
 * 
 * Class Invariant: 
 *    mySize == 0 ||
 *    mySize > 0 && myArray[myFirst] == getFirst()
 *               && myArray[myLast] == getLast().
 * 
 *  (When I am not empty:
 *     myFirstIndex is the index of my oldest value;
 *     myLastIndex is the index of my newest value.)
 */

#ifndef ARRAY_QUEUE_H_
#define ARRAY_QUEUE_H_

#include "QueueException.h"
#include <memory.h>

template<class Item>
class ArrayQueue {
public:
	ArrayQueue(unsigned myCapacity);
	ArrayQueue(const ArrayQueue<Item>& original);
	virtual ~ArrayQueue();
	ArrayQueue<Item>& operator=(const ArrayQueue<Item>& original);
	unsigned getSize() const;
	unsigned getCapacity() const;
	bool isEmpty() const;
	bool isFull() const;
	void append(const Item& it);
	Item getFirst() const;
	Item getLast() const;
	Item remove();
	void setCapacity(unsigned newCapacity);

protected:
	virtual void makeCopyOf(const ArrayQueue<Item>& original);
private:
	unsigned mySize;       // number of items I contain
	unsigned myCapacity;   // how many items I can store
	unsigned myFirstIndex; // index of oldest item (if any)
	unsigned myLastIndex;  // index of newest item (if any)
	Item*    myArrayPtr;   // dynamic array of items

	friend class ArrayQueueTester;
};

/* Default constructor
 * @param:
 * Postcondition:
 */
template<class Item>
ArrayQueue<Item>::ArrayQueue( unsigned capacity ) {
	if ( capacity <= 0 ) {
		throw QueueException( "Constructor", "Invalid capacity!" );
	} else {
		myArrayPtr = new Item[capacity]();
	}
	myCapacity = capacity;
	mySize = myFirstIndex = myLastIndex = 0;
}

/* copy constructor
 * @param: original, the ArrayQueue to be copied.
 * Postcondition: I am a deep copy of original.
 */
template<class Item>
ArrayQueue<Item>::ArrayQueue(const ArrayQueue<Item>& original) {
	makeCopyOf(original);
}

/* utility method to build copies
 * @param: original, the ArrayQueue to be copied.
 * Postcondition: I am a deep copy of original.
 */
template<class Item>
void ArrayQueue<Item>::makeCopyOf(const ArrayQueue<Item>& original) {
	mySize = original.mySize;
	myCapacity = original.myCapacity;
	myFirstIndex = original.myFirstIndex;
	myLastIndex = original.myLastIndex;
	myArrayPtr = new Item[myCapacity];
	memcpy(myArrayPtr, original.myArrayPtr, myCapacity*sizeof(Item) );
}

/* destructor
 * Postcondition: my dynamic array has been deallocated.
 */
template<class Item>
ArrayQueue<Item>::~ArrayQueue() {
	delete [] myArrayPtr;
	myArrayPtr = NULL;
	mySize = myFirstIndex = 0;
	myLastIndex = myCapacity;
}

/* assignment operator
 * @param: aQueue, an ArrayQueue/
 * @return: myself.
 * Postcondition: I am a deep copy of aQueue.
 */
template<class Item>
ArrayQueue<Item>& ArrayQueue<Item>::operator=(const ArrayQueue<Item>& aQueue) {
	if (this != &aQueue) {
		delete [] myArrayPtr;
		makeCopyOf(aQueue);
	}
	return *this;
}

/* Am I empty?
 * @return: true if I am empty, false othewise.
 */
template<class Item>
bool ArrayQueue<Item>::isEmpty() const {
	return mySize == 0;
}

/* Am I full?
 * @return: true if I am full, false othewise.
 */
template<class Item>
bool ArrayQueue<Item>::isFull() const {
	return getSize() == myCapacity;
}

/* accessor for myCapacity
 * @return myCapacity.
 */
template<class Item>
unsigned ArrayQueue<Item>::getCapacity() const {
	return myCapacity;
}

/* accessor for mySize
 * @return mySize.
 */
template<class Item>
unsigned ArrayQueue<Item>::getSize() const {
	return mySize;
}

template<class Item>
Item ArrayQueue<Item>::getFirst() const {
	if ( isEmpty()) {
		throw EmptyQueueException("getFirst()");
	}
	return myArrayPtr[ myFirstIndex ];
}

template<class Item>
Item ArrayQueue<Item>::getLast() const {
	if ( isEmpty() ) {
		throw EmptyQueueException("getLast()");
	}
	return myArrayPtr[ ( myLastIndex + myCapacity - 1 ) % myCapacity ];
}

template<class Item>
void ArrayQueue<Item>::append(const Item& it) {
	if ( isFull() ) {
		throw FullQueueException("append()");
	}
	myArrayPtr[ myLastIndex++ % myCapacity ] = it;
	mySize++;
}

template<class Item>
Item ArrayQueue<Item>::remove() {
	if ( isEmpty() ) {
		throw EmptyQueueException("remove()");
	}
	Item result = myArrayPtr[ myFirstIndex ];
	myFirstIndex = (myFirstIndex+1)%myCapacity;
	mySize--;
	return result;
}

/* Sets a new myCapacity value
 * @param:			newCapacity, an unsigned
 * Precondition:	contains value of newCapacity
 * Postcondition:	myCapacity now equals newCapacity
 * Postcondition:	myArray has been up/downsized
 * AUTHORED BY:		Michael Sisko
 */
template<class Item>
void ArrayQueue<Item>::setCapacity(unsigned newCapacity) {
	if (myCapacity != newCapacity) {
		if ( newCapacity < mySize || newCapacity == 0 ) {
			throw QueueException("setCapacity()", "invalid capacity");
		}
		Item* newArrayPtr = new Item[newCapacity]();
		for ( unsigned i = myFirstIndex; i < mySize+myFirstIndex; i++) {
			newArrayPtr[i - myFirstIndex] = myArrayPtr[i % myCapacity];
		}
		myCapacity = newCapacity;
		delete [] myArrayPtr;
		myArrayPtr = newArrayPtr;
		myFirstIndex = 0;
		myLastIndex = mySize;
	}
}

#endif /*ARRAY_QUEUE_H_*/









///* ArrayQueue.cpp defines the methods for class ArrayQueue.
// * Joel Adams, for CS 112 at Calvin University.
// * Student name:
// * Date:
// */
//
//#include "ArrayQueue.h"
//#include <cstring>      // memcpy()
//using namespace std;
//
///* Default constructor
// * @param:
// * Postcondition:
// */
//ArrayQueue::ArrayQueue( unsigned capacity ) {
//	if ( capacity <= 0 ) {
//		throw QueueException( "Constructor", "Invalid capacity!" );
//	} else {
//		myArrayPtr = new Item[capacity]();
//	}
//	myCapacity = capacity;
//	mySize = myFirstIndex = myLastIndex = 0;
//}
//
///* copy constructor
// * @param: original, the ArrayQueue to be copied.
// * Postcondition: I am a deep copy of original.
// */
//ArrayQueue::ArrayQueue(const ArrayQueue& original) {
//	makeCopyOf(original);
//}
//
///* utility method to build copies
// * @param: original, the ArrayQueue to be copied.
// * Postcondition: I am a deep copy of original.
// */
//void ArrayQueue::makeCopyOf(const ArrayQueue& original) {
//	mySize = original.mySize;
//	myCapacity = original.myCapacity;
//	myFirstIndex = original.myFirstIndex;
//	myLastIndex = original.myLastIndex;
//	myArrayPtr = new Item[myCapacity];
//	memcpy(myArrayPtr, original.myArrayPtr, myCapacity*sizeof(Item) );
//}
//
///* destructor
// * Postcondition: my dynamic array has been deallocated.
// */
//ArrayQueue::~ArrayQueue() {
//	delete [] myArrayPtr;
//	myArrayPtr = NULL;
//	mySize = myFirstIndex = 0;
//	myLastIndex = myCapacity;
//}
//
///* assignment operator
// * @param: aQueue, an ArrayQueue/
// * @return: myself.
// * Postcondition: I am a deep copy of aQueue.
// */
//ArrayQueue& ArrayQueue::operator=(const ArrayQueue& aQueue) {
//	if (this != &aQueue) {
//		delete [] myArrayPtr;
//		makeCopyOf(aQueue);
//	}
//	return *this;
//}
//
///* Am I empty?
// * @return: true if I am empty, false othewise.
// */
//bool ArrayQueue::isEmpty() const {
//	return mySize == 0;
//}
//
///* Am I full?
// * @return: true if I am full, false othewise.
// */
//bool ArrayQueue::isFull() const {
//	return getSize() == myCapacity;
//}
//
///* accessor for myCapacity
// * @return myCapacity.
// */
//unsigned ArrayQueue::getCapacity() const {
//	return myCapacity;
//}
//
///* accessor for mySize
// * @return mySize.
// */
//unsigned ArrayQueue::getSize() const {
//	return mySize;
//}
//
//Item ArrayQueue::getFirst() const {
//	if ( isEmpty()) {
//		throw EmptyQueueException("getFirst()");
//	}
//	return myArrayPtr[ myFirstIndex ];
//}
//
//Item ArrayQueue::getLast() const {
//	if ( isEmpty() ) {
//		throw EmptyQueueException("getLast()");
//	}
//	return myArrayPtr[ ( myLastIndex + myCapacity - 1 ) % myCapacity ];
//}
//
//void ArrayQueue::append(const Item& it) {
//	if ( isFull() ) {
//		throw FullQueueException("append()");
//	}
//	myArrayPtr[ myLastIndex++ % myCapacity ] = it;
//	mySize++;
//}
//
//Item ArrayQueue::remove() {
//	if ( isEmpty() ) {
//		throw EmptyQueueException("remove()");
//	}
//	Item result = myArrayPtr[ myFirstIndex ];
//	myFirstIndex = (myFirstIndex+1)%myCapacity;
//	mySize--;
//	return result;
//}









/* ArrayQueueTester.h declares the class that tests class ArrayQueue.
 * Joel Adams, for CS 112 at Calvin University.
 */
 
#ifndef QUEUETESTER_H_
#define QUEUETESTER_H_

#include "ArrayQueue.h"
#include <cassert>

class ArrayQueueTester {
public:
	void runTests();
	void testConstructor();
	void testAppend();
	void testRemove();
	void testCopyConstructor();
	void testAssignment();
	void testSetCapacity();
};

#endif /*QUEUETESTER_H_*/









/* QueueTester.cpp defines the test-methods for class Queue.
 * Joel Adams, for CS 112 at Calvin University.
 */

#include "ArrayQueueTester.h"
#include <iostream>
#include <cstdlib>          // exit()
using namespace std;

void ArrayQueueTester::runTests() {
	cout << "Testing class ArrayQueue..." << endl;
	testConstructor();
	testAppend();
	testRemove();
	testCopyConstructor();
	testAssignment();
	testSetCapacity();
	cout << "All tests passed!\n" << endl;
}

void ArrayQueueTester::testAssignment() {
	cout << "- testing assignment... " << flush;
	// empty, smaller-to-bigger;
	ArrayQueue<int> q1(4);
	ArrayQueue<int> q2(3);
	q1 = q2;
	assert( q1.isEmpty() );
	assert( q1.myCapacity == 3 );
	assert( q1.getSize() == 0 );
	assert( q1.myFirstIndex == q2.myFirstIndex );
	assert( q1.myLastIndex == q2.myLastIndex );
	assert( q1.myArrayPtr != q2.myArrayPtr );
	cout << " 1 " << flush;
	//empty, bigger to smaller
	ArrayQueue<int> q3(3);
	ArrayQueue<int> q4(4);
	q3 = q4;
	assert( q3.isEmpty() );
	assert( q3.myCapacity == 4 );
	assert( q3.getSize() == 0 );
	assert( q3.myFirstIndex == q4.myFirstIndex );
	assert( q3.myLastIndex == q4.myLastIndex );
	assert( q3.myArrayPtr != q4.myArrayPtr );
	cout << " 2 " << flush;
	// full, same-sized
	ArrayQueue<int> q5(4);
	q5.append(11);
	q5.append(22);
	q5.append(33);
	q5.append(44);
	ArrayQueue<int> q6(4);
	q6 = q5;
	assert( q6.isFull() );
	assert( !q6.isEmpty() );
	assert( q6.myCapacity == 4 );
	assert( q6.getSize() == 4 );
	assert( q6.myFirstIndex == q5.myFirstIndex );
	assert( q6.myLastIndex == q5.myLastIndex );
	for (unsigned i = 0; i < q6.myCapacity; i++) {
		assert( q6.myArrayPtr[i] == q5.myArrayPtr[i] );
	}
	assert( q6.myArrayPtr != q5.myArrayPtr );
	cout << " 3 " << flush;
	// full, smaller-to-larger
	ArrayQueue<int> q7(3);
	q7 = q5;
	assert( q7.isFull() );
	assert( !q7.isEmpty() );
	assert( q7.myCapacity == 4 );
	assert( q7.getSize() == 4 );
	assert( q7.myFirstIndex == q5.myFirstIndex );
	assert( q7.myLastIndex == q5.myLastIndex );
	for (unsigned i = 0; i < q7.myCapacity; i++) {
		assert( q7.myArrayPtr[i] == q5.myArrayPtr[i] );
	}
	assert( q7.myArrayPtr != q5.myArrayPtr );
	cout << " 4 " << flush;
	// full, larger-to-smaller
	ArrayQueue<int> q8(5);
	q8 = q5;
	assert( q8.isFull() );
	assert( !q8.isEmpty() );
	assert( q8.myCapacity == 4 );
	assert( q8.getSize() == 4 );
	assert( q8.myFirstIndex == q5.myFirstIndex );
	assert( q8.myLastIndex == q5.myLastIndex );
	for (unsigned i = 0; i < q8.myCapacity; i++) {
		assert( q8.myArrayPtr[i] == q5.myArrayPtr[i] );
	}
	assert( q8.myArrayPtr != q5.myArrayPtr );
	cout << " 5 " << flush;
	// self assignment
	q5 = q5;
	assert( q5.isFull() );
	assert( !q5.isEmpty() );
	assert( q5.myCapacity == 4 );
	assert( q5.getSize() == 4 );
	assert( q5.myArrayPtr[0] == 11 );
	assert( q5.myArrayPtr[1] == 22 );
	assert( q5.myArrayPtr[2] == 33 );
	assert( q5.myArrayPtr[3] == 44 );
	cout << " 6 " << flush;
	// chaining
	q1 = q3 = q5;
	assert( q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.myCapacity == 4 );
	assert( q1.getSize() == 4 );
	assert( q1.myArrayPtr[0] == 11 );
	assert( q1.myArrayPtr[1] == 22 );
	assert( q1.myArrayPtr[2] == 33 );
	assert( q1.myArrayPtr[3] == 44 );
	assert( q1.myArrayPtr != q3.myArrayPtr );
	assert( q1.myArrayPtr != q5.myArrayPtr );
	assert( q3.myArrayPtr != q5.myArrayPtr );
	cout << " 7 " << flush;
	cout << "Passed!" << endl;
}

void ArrayQueueTester::testCopyConstructor() {
	cout << "- testing copy constructor... " << flush;
	// empty queue
	ArrayQueue<int> q1(4);
	ArrayQueue<int> q2(q1);
	assert( q2.isEmpty() );
	assert( !q2.isFull() );
	assert( q2.myCapacity == q1.myCapacity);
	assert( q2.myFirstIndex == q1.myFirstIndex );
	assert( q2.myLastIndex == q1.myLastIndex );
	assert( q2.myArrayPtr != q1.myArrayPtr );
	cout << " 1 " << flush;
	// queue of 1 int
	ArrayQueue<int> q3(4);
	q3.append(11);
	ArrayQueue<int> q4(q3);
	assert( !q4.isFull() );
	assert( !q4.isEmpty() );
	assert( q4.myCapacity == q3.myCapacity);
	assert( q4.myFirstIndex == q3.myFirstIndex );
	assert( q4.myLastIndex == q3.myLastIndex );
	assert( q4.myArrayPtr != q3.myArrayPtr );
	assert( q4.getFirst() == 11 );
	assert( q4.getLast() == 11 );
	assert( q4.myArrayPtr != q3.myArrayPtr );
	cout << " 2 " << flush;
	// full queue
	q3.append(22);
	q3.append(33);
	q3.append(44);
	ArrayQueue<int> q5(q3);
	assert( q5.isFull() );
	assert( !q5.isEmpty() );
	assert( q5.myCapacity == q3.myCapacity);
	assert( q5.myFirstIndex == q3.myFirstIndex );
	assert( q5.myLastIndex == q3.myLastIndex );
	assert( q5.myArrayPtr != q3.myArrayPtr );
	assert( q5.getFirst() == 11 );
	assert( q5.getLast() == 44 );
	assert( q5.myArrayPtr != q3.myArrayPtr );
	cout << " 3 " << flush;
	cout << "Passed!" << endl;
}

void ArrayQueueTester::testRemove() {
	cout << "- testing remove()... " << flush;
	ArrayQueue<int> q1(4);
	cout << " 0 " << flush;
	// check with empty queue
	try {
		q1.remove();
		cerr << "\nremove() worked on empty Queue - 1\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 1 " << flush;
	}
	// check with 1 int
	q1.append(1);
	assert( !q1.isEmpty() );
	assert( q1.remove() == 1 );
	assert( q1.isEmpty() );
	cout << " 2 " << flush;
	// check with 2 ints
	q1.append(11);
	q1.append(22);
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 22 );
	assert( q1.remove() == 11 );
	assert( q1.getFirst() == 22 );
	assert( q1.getLast() == 22 );
	assert( q1.remove() == 22 );
	assert( q1.isEmpty() );
	cout << " 3 " << flush;
	// load it up
	q1.append(111);
	q1.append(222);
	q1.append(333);
	q1.append(444);
	assert( q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 111 );
	assert( q1.getLast() == 444 );
	// start removing ints
	assert( q1.remove() == 111 );
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 222 );
	assert( q1.getLast() == 444 );
	cout << " 4a " << flush;
	assert( q1.remove() == 222 );
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 333 );
	assert( q1.getLast() == 444 );
	cout << " 4b " << flush;
	assert( q1.remove() == 333 );
	assert( !q1.isFull() );
	assert( !q1.isEmpty() );
	assert( q1.getFirst() == 444 );
	assert( q1.getLast() == 444 );
	cout << " 4c " << flush;
	assert( q1.remove() == 444 );
	assert( !q1.isFull() );
	assert( q1.isEmpty() );
	cout << " 4d " << flush;
	// recheck empty queue
	try {
		q1.remove();
		cerr << "\nremove() worked on empty Queue - 2\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 5 " << flush;
	}
	ArrayQueue<int> q2(5000);
	cout << " 6a " << flush;
	for (int i = 5000; i > 0; i--) {
		q2.append(i);
	}
	assert( q2.isFull() );
	cout << " 6b " << flush;
	for (int i = 5000; i > 0; i--) {
		assert( q2.remove() == i );
	}
	assert( q2.isEmpty() );
	cout << " 6c " << flush;
	cout << "Passed!" << endl;
}

void ArrayQueueTester::testAppend() {
	cout << "- testing append(), getFirst(), getLast() ... " << flush;
	ArrayQueue<int> q1(4);
	assert( q1.isEmpty() );
	assert( !q1.isFull() );
	try {
		q1.getFirst();
		cerr << "\ngetFirst() worked on empty queue\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 0a " << flush;
	}
	try {
		q1.getLast();
		cerr << "\ngetLast() worked on empty queue\n";
		exit(1);
	} catch (EmptyQueueException& eqe) {
		cout << " 0b " << flush;
	}
	q1.append(11);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 11 );
	cout << " 1 " << flush;
	q1.append(22);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 22 );
	cout << " 2 " << flush;
	q1.append(33);
	assert( !q1.isEmpty() );
	assert( !q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 33 );
	cout << " 3 " << flush;
	q1.append(44);
	assert( !q1.isEmpty() );
	assert( q1.isFull() );
	assert( q1.getFirst() == 11 );
	assert( q1.getLast() == 44 );
	cout << " 4 " << flush;
	// append to full queue
	try {
		q1.append(55);
		cerr << "\nappend() worked on full queue\n";
		exit(1);
	} catch (FullQueueException& fqe) {
		cout << " 5 " << flush;
	}
	cout << "Passed, but wrap-around not tested..." << endl;
}

void ArrayQueueTester::testConstructor() {
	cout << "- testing constructor... " << flush;
	// try with capacity zero
	try {
		ArrayQueue<int> q1(0);
		cerr << "Constructed Queue with capacity zero" << endl;
		exit(1);
	} catch (QueueException& qe) {
		cout << " 1 " << flush;
	}

	// positive capacity
	ArrayQueue<int> q2(3);
	assert( q2.isEmpty() );
	assert( !q2.isFull() );
	assert( q2.myCapacity == 3 );
	cout << " 2 " << flush;
	cout << " Passed!" << endl;
}

void ArrayQueueTester::testSetCapacity() {
	cout << "- testing setCapacity()... " << flush;

	// same capacity while empty
	ArrayQueue<int> aq0(1);
	aq0.setCapacity(1);
	assert( aq0.getCapacity() == 1 );
	assert( aq0.getSize() == 0 );
	assert( aq0.isEmpty() );
	assert( !aq0.isFull() );
	cout << " 0a " << flush;

	// increase capacity while empty
	aq0.setCapacity(2);
	assert( aq0.getCapacity() == 2 );
	assert( aq0.getSize() == 0 );
	assert( aq0.isEmpty() );
	assert( !aq0.isFull() );
	cout << " 0b " << flush;

	// decrease capacity while empty
	aq0.setCapacity(1);
	assert( aq0.getCapacity() == 1 );
	assert( aq0.getSize() == 0 );
	assert( aq0.isEmpty() );
	assert( !aq0.isFull() );
	cout << " 0c " << flush;

	// same capacity while full
	ArrayQueue<int> aq1(1);
	aq1.append(11);
	aq1.setCapacity(1);
	assert( aq1.getCapacity() == 1 );
	assert( aq1.getSize() == 1 );
	assert( !aq1.isEmpty() );
	assert( aq1.isFull() );
	cout << " 1a " << flush;

	// increase capacity while full
	aq1.setCapacity(2);
	assert( aq1.getCapacity() == 2 );
	assert( aq1.getSize() == 1 );
	assert( !aq1.isEmpty() );
	assert( !aq1.isFull() );
	cout << " 1b " << flush;

	// decrease capacity while full
	aq1.append(22);
	try {
		aq1.setCapacity(0);
		cerr << "setCapacity(0) worked!" << endl;
		exit(1);
	} catch ( QueueException& qe ) {
		assert( aq1.getCapacity() == 2 );
		assert( aq1.getSize() == 2 );
		assert( !aq1.isEmpty() );
		assert( aq1.isFull() );
		cout << " 1c " << flush;
	}

	// attempt set capacity 0 while full
	try {
		aq1.setCapacity(0);
		cerr << "setCapacity(0) worked!" << endl;
		exit(1);
	} catch ( QueueException& qe ) {
		assert( aq1.getCapacity() == 2 );
		assert( aq1.getSize() == 2 );
		assert( !aq1.isEmpty() );
		assert( aq1.isFull() );
	}

	// attempt set capacity 0 while !full !empty
	aq1.remove();
	try {
		aq1.setCapacity(0);
		cerr << "setCapacity(0) worked!" << endl;
		exit(1);
	} catch ( QueueException& qe ) {
		assert( aq1.getCapacity() == 2 );
		assert( aq1.getSize() == 1 );
		assert( !aq1.isEmpty() );
		assert( !aq1.isFull() );
	}

	// attempt set capacity 0 while empty
	aq1.remove();
	try {
		aq1.setCapacity(0);
		cerr << "setCapacity(0) worked!" << endl;
		exit(1);
	} catch ( QueueException& qe ) {
		assert( aq1.getCapacity() == 2 );
		assert( aq1.getSize() == 0 );
		assert( aq1.isEmpty() );
		assert( !aq1.isFull() );
		cout << " 2 " << flush;
	}

	// attempt decrease capacity below size
	aq1.append(11);
	aq1.append(22);
	try {
		aq1.setCapacity(1);
		cerr << "setCapacity() invalid size worked!" << endl;
		exit(1);
	} catch ( QueueException& qe ) {
		assert( aq1.getCapacity() == 2 );
		assert( aq1.getSize() == 2 );
		assert( !aq1.isEmpty() );
		assert( aq1.isFull() );
		cout << " 3 " << flush;
	}

	// verify working cond. of getters and modifiers
	ArrayQueue<int> aq2(5);
	for (unsigned i=1; i<=5; ++i) {
		aq2.append(i*11);
	}
	aq2.setCapacity(7);
	assert( aq2.getCapacity() == 7 );
	assert( aq2.getSize() == 5 );
	assert( aq2.getFirst() == 11 );
	assert( aq2.getLast() == 55 );
	assert( !aq2.isEmpty() );
	assert( !aq2.isFull() );
	assert( aq2.remove() == 11 );
	aq2.append(66);
	aq2.append(77);
	assert( aq2.getSize() == 6 );
	assert( aq2.getFirst() == 22 );
	assert( aq2.getLast() == 77 );
	assert( !aq2.isEmpty() );
	assert( !aq2.isFull() );
	cout << " 4 " << flush;

	// decrease capacity to value >= mySize
	aq2.remove();
	aq2.setCapacity(5);
	assert( aq2.getCapacity() == 5 );
	assert( aq2.getSize() == 5 );
	assert( !aq2.isEmpty() );
	assert( aq2.isFull() );
	cout << " 5 " << flush;

	cout << " Passed!" << endl;
}









/* QueueException.h provides a simple exception class for Queues to throw,
 *   plus subclasses (EmptyQueueException, FullQueueException)
 *   for more fine-grained error-handling.
 * See Exception.h for its superclass.
 * Joel Adams, for CS 112 at Calvin University.
 */
 
#ifndef QUEUEEXCEPTION_H_
#define QUEUEEXCEPTION_H_

#include "Exception.h"

class QueueException : public Exception {
public:
   QueueException(const string& whereThrown, const string& message)
   : Exception(whereThrown, message)
   {}
   
   virtual string className() const {
   	 return "QueueException";
   }
};

class EmptyQueueException : public QueueException {
public:
   EmptyQueueException(const string& whereThrown)
    : QueueException(whereThrown, "queue is empty")
   {}
   
   virtual string className() const {
   	  return "EmptyQueueException";
   }
};

class FullQueueException : public QueueException {
public:
   FullQueueException(const string& whereThrown)
    : QueueException(whereThrown, "queue is full")
   {}
   
   virtual string className() const {
   	  return "FullQueueException";
   }
};


#endif /*QUEUEEXCEPTION_H_*/









/* Stack.h provides a (dynamic-array-based) Stack class.
 * Joel Adams, for CS 112 at Calvin University.
 * Student Name:
 * Date:
 * 
 * Invariant: mySize == 0 && isEmpty() && !isFull()
 *         || mySize == myCapacity && !isEmpty() && isFull()
 *         || mySize > 0 && mySize < myCapacity && !isEmpty() && !isFull().
 * Notes: 
 * 1. Member mySize always contains the index of the next empty space in myArray
 *        (the index of the array element into which the next pushed item will be placed).
 * 2. Sending push() to a full Stack throws the exception Stack::Overflow.
 * 3. Sending pop() or peekTop() to an empty Stack throws the exception Stack::Underflow.
 */

#ifndef STACK_H_
#define STACK_H_

#include "StackException.h"
#include <string>
#include <iostream>
using namespace std;

template<class Item>
class Stack {
public:
	Stack<Item>(unsigned capacity);
	Stack<Item>(const Stack<Item>& original);
	~Stack();
	Stack<Item>& operator=(const Stack<Item>& original);
	bool isEmpty() const { return mySize == 0; }
	bool isFull() const { return mySize == myCapacity; }
	Item peekTop() const;
	void push(const Item& it);
	Item pop();
	unsigned getCapacity() const;
	unsigned getSize() const;
	void setCapacity(unsigned newCapacity);

protected:
	void makeCopyOf(const Stack<Item>& original);

private:
	unsigned myCapacity;
	unsigned mySize;
	Item*    myArray;
	friend class StackTester;
};

/* explicit-value constructor
 * Parameter: capacity, an unsigned value.
 * Precondition: capacity > 0.
 * Postcondition: mySize == 0 && myCapacity == capacity
 *              && myArray contains the address of a dynamic array of 'capacity' entries.
 */
template<class Item>
Stack<Item>::Stack(unsigned capacity) {
	mySize = 0;
	myCapacity = capacity;
	myArray = new Item[capacity];
}

/* copy constructor
 * Parameter: original, a Stack (const reference).
 * Postcondition: I am a copy of original.
 */
template<class Item>
Stack<Item>::Stack(const Stack<Item>& original) {
	makeCopyOf(original);
}

/* utility method containing code refactored from
 *  the copy constructor and operator=.
 * Parameter: original, a Stack (const reference).
 * Precondition: original.myCapacity > 0.
 * Postcondition: I am a copy of original.
 */
template<class Item>
void Stack<Item>::makeCopyOf(const Stack<Item>& original) {
	myCapacity = original.myCapacity;
	myArray = new Item[myCapacity];

	for (unsigned i = 0; i < myCapacity; i++) {
		myArray[i] = original.myArray[i];
	}
	mySize = original.mySize;
}

/* destructor
 * Postcondition: myCapacity == 0 && mySize == 0
 *             && myArray has been deallocated.
 */
template<class Item>
Stack<Item>::~Stack() {
	delete [] myArray;
	myArray = NULL;
	myCapacity = 0;
	mySize = 0;
}

/* assignment operator
 * Parameter: original, a Stack (const reference).
 * Postcondition: I am a copy of original
 *              && I have been returned.
 */
template<class Item>
Stack<Item>& Stack<Item>::operator=(const Stack<Item>& original) {
	if (this != &original) {
		delete [] myArray;
		makeCopyOf(original);
	}
	return *this;
}

template<class Item>
Item Stack<Item>::peekTop() const {
	if ( isEmpty() ) {
		throw StackException("peekTop()", "stack is empty");
	}
	return myArray[mySize-1];
}

template<class Item>
void Stack<Item>::push(const Item& it) {
	if ( isFull() ) {
		throw StackException("push()", "stack is full");
	}
	myArray[mySize++] = it;
}

template<class Item>
Item Stack<Item>::pop() {
	if ( isEmpty() ) {
		throw StackException("pop()", "stack is empty");
	}
	return myArray[--mySize];
}

/* Getter for myCapacity
 * @param:			none
 * Precondition:	none
 * Postcondition:	returns myCapacity
 * AUTHORED BY:		Michael Sisko
 */
template<class Item>
unsigned Stack<Item>::getCapacity() const {
	return myCapacity;
}

/* Getter for mySize
 * @param:			none
 * Precondition:	none
 * Postcondition:	returns mySize
 * AUTHORED BY:		Michael Sisko
 */
template<class Item>
unsigned Stack<Item>::getSize() const {
	return mySize;
}

/* Sets a new myCapacity value
 * @param:			newCapacity, an unsigned
 * Precondition:	contains value of newCapacity
 * Postcondition:	myCapacity now equals newCapacity
 * Postcondition:	myArray has been upsized
 * AUTHORED BY:		Michael Sisko
 */
template<class Item>
void Stack<Item>::setCapacity(unsigned newCapacity) {
	if (myCapacity != newCapacity) {
		if ( newCapacity < myCapacity || newCapacity == 0 ) {
			throw StackException("setCapacity()", "invalid capacity");
		} else {
			Item* newArray;
			newArray = new Item[newCapacity]();
			for ( unsigned i = 0; i < myCapacity; i++) {
				newArray[i] = myArray[i];
			}
			myCapacity = newCapacity;
			delete [] myArray;
			myArray = newArray;
		}
	}
}

#endif









/* StackTester.h declares a test-class for a dynamically allocated (array) Stack.
 * Joel Adams, for CS 112 at Calvin University
 */

#ifndef STACKTESTER_H_
#define STACKTESTER_H_


class StackTester {
public:
	void runTests();
	void testConstructor();
	void testIsEmpty();
	void testPushPeekTopAndIsFull();
	void testPop();
	void testCopyConstructor();
	void testAssignment();
	void testDestructor();
	void testGetCapacity();
	void testGetSize();
	void testSetCapacity();
};

#endif /*STACKTESTER_H_*/









/* StackTester.cpp defines test-methods for the 
 *  dynamically allocated (array) Stack operations
 * Joel Adams, for CS 112 at Calvin University
 */

#include "StackTester.h"
#include "Stack.h"
#include <iostream>  // cout, cerr, ...
#include <cassert>   // assert()
#include <cstdlib>   // exit()
using namespace std;

void StackTester::runTests() {
	cout << "Testing Stack class..." << endl;
	testConstructor();
	testIsEmpty();
	testPushPeekTopAndIsFull();
	testPop();
	testCopyConstructor();
	testAssignment();
	testDestructor();
	testGetCapacity();
	testGetSize();
	testSetCapacity();
	cout << "All tests passed!" << endl;
}

void StackTester::testConstructor() {
	cout << "- Testing constructor... " << flush;
	// invalid parameter
	//	try {
	Stack<unsigned> s1(0);
	//		cerr << "\nConstructed stack of size 0\n";
	//		exit(1);
	//	} catch (const StackException& se) {
	//		cout << se << flush;
	//		cout << " 0 " << flush;
	//	}
	// valid parameter
	Stack<unsigned> s2(3);
	cout << " 1 " << flush;
	cout << " Passed!" << endl;
}

void StackTester::testIsEmpty() {
	cout << "- Testing isEmpty()... " << flush;
	// capacity 1
	Stack<unsigned> s1(1);
	assert( s1.isEmpty() );
	cout << " 1 " << flush;
	// capacity > 1
	Stack<unsigned> s2(3);
	assert( s2.isEmpty() );
	cout << " 2 " << flush;
	cout << " Passed!" << endl;
}


void StackTester::testPushPeekTopAndIsFull() {
	cout << "- Testing push()... " << flush;
	// test with capacity 1
	Stack<unsigned> s1(1);
	s1.push(11);
	assert( s1.peekTop() == 11 );
	assert( !s1.isEmpty() );
	assert( s1.isFull() );
	try {
		s1.push(22);
		cerr << "\npush() worked on a full stack (size 1)\n";
		exit(1);
	} catch (const StackException& se) {
		cout << " 1 " << flush;
	}
	// test with capacity > 1
	Stack<unsigned> s2(3);
	s2.push(11);
	assert( s2.peekTop() == 11 );
	s2.push(22);
	assert( s2.peekTop() == 22 );
	s2.push(33);
	assert( s2.peekTop() == 33 );
	try {
		s2.push(44);
		cerr << "\npush() worked on a full stack (size 3)\n";
		exit(1);
	} catch (const StackException& se) {
		cout << " 2 " << flush;
	}
	cout << " Passed! " << endl;
}

void StackTester::testPop() {
	cout << "- Testing pop()... " << flush;
	// try empty, capacity 1
	Stack<unsigned> s1(1);
	assert( s1.isEmpty() );
	try {
		s1.peekTop();
		cerr << "\npeekTop() worked on empty stack (size 1)\n";
		exit(1);
	} catch (const StackException& se) {
		cout << " 0a " << flush;
	}
	try {
		s1.pop();
		cerr << "\npop() worked on empty stack (size 1)\n";
		exit(1);
	} catch (const StackException& se) {
		cout << " 0b " << flush;
	}

	// try empty, capacity > 1
	Stack<unsigned> s2(3);
	try {
		s2.pop();
		cerr << "\npop() worked on empty stack (size 3)\n";
		exit(1);
	} catch (const StackException& se) {
		cout << " 1a " << flush;
	}
	try {
		s2.peekTop();
		cerr << "\npeekTop() worked on empty stack (size 3)\n";
		exit(1);
	} catch (const StackException& se) {
		cout << " 1b " << flush;
	}

	// try non-empty, capacity 1
	Stack<unsigned> s3(1);
	s3.push(11);
	assert( s3.peekTop() == 11 );
	assert( s3.pop() == 11 );
	cout << " 2 " << flush;
	try {
		s3.pop();
		cerr << "\ns3.pop() worked on empty stack (size 1)\n";
		exit(1);
	} catch (const StackException& se) {
		cout << " 2a " << flush;
	}
	try {
		s3.peekTop();
		cerr << "\ns3.peekTop() worked on empty stack (size 1)\n";
		exit(1);
	} catch (const StackException& se) {
		cout << " 2b " << flush;
	}

	// try non-empty, capacity > 1
	Stack<unsigned> s4(3);
	s4.push(11);
	s4.push(22);
	s4.push(33);
	assert( s4.peekTop() == 33 );
	assert( s4.pop() == 33 );
	assert( s4.peekTop() == 22 );
	assert( s4.pop() == 22 );
	assert( s4.peekTop() == 11 );
	assert( s4.pop() == 11 );
	cout << " 3 " << flush;
	try {
		s4.pop();
		cerr << "\ns4.pop() worked on empty stack (size 3)\n";
		exit(1);
	} catch (const StackException& se) {
		cout << " 3a " << flush;
	}
	try {
		s4.peekTop();
		cerr << "\ns4.peekTop() worked on empty stack (size 3)\n";
		exit(1);
	} catch (const StackException& se) {
		cout << " 3b " << flush;
	}

	cout << " Passed!" << endl;
}

void StackTester::testCopyConstructor() {
	cout << "- Testing copy constructor... " << flush;
	// minimal empty Stack
	Stack<unsigned> s1(1);
	Stack<unsigned> s2(s1);
	assert( s2.isEmpty() );
	assert( s2.myArray != NULL );
	assert( s2.myCapacity == 1 );
	assert( s2.myArray != s1.myArray );
	cout << " 1 " << flush;
	// minimal non-empty Stack
	Stack<unsigned> s3(1);
	s3.push(11);
	Stack<unsigned> s4(s3);
	assert( !s4.isEmpty() );
	assert( s4.isFull() );
	assert( s4.peekTop() == 11 );
	assert( s4.myArray != s3.myArray );
	cout << " 2 " << flush;
	// non-minimal, non-empty stack
	Stack<unsigned> s5(3);
	s5.push(11);
	s5.push(22);
	s5.push(33);
	Stack<unsigned> s6(s5);
	assert( s6.myCapacity == s5.myCapacity );
	assert( s6.mySize == s5.mySize );
	assert( s6.myArray != s5.myArray );
	assert( s6.pop() == 33 );
	assert( s6.pop() == 22 );
	assert( s6.pop() == 11 );
	assert( s5.peekTop() == 33 );
	cout << " 3 " << flush;
	cout << "Passed!" << endl;
}

void StackTester::testAssignment() {
	cout << "- Testing assignment... " << flush;
	// minimal empty Stacks, same size
	Stack<unsigned> s1(1);
	Stack<unsigned> s2(1);
	s2 = s1;
	assert( s2.isEmpty() );
	assert( s2.myArray != NULL );
	assert( s2.myArray != s1.myArray );
	assert( s2.myCapacity == 1 );
	cout << " 1 " << flush;
	// minimal non-empty Stack to empty Stack, same capacity
	Stack<unsigned> s3(1);
	s3.push(11);
	Stack<unsigned> s4(1);
	s4 = s3;
	assert( !s4.isEmpty() );
	assert( s4.isFull() );
	assert( s4.peekTop() == 11 );
	assert( s4.myArray != s3.myArray );
	cout << " 2 " << flush;
	// minimal empty stack to non-empty stack, same capacity
	Stack<unsigned> s5(1);
	Stack<unsigned> s6(1);
	s6.push(11);
	s6 = s5;
	assert( s6.isEmpty() );
	assert( s6.myArray != NULL );
	assert( s6.myArray != s5.myArray );
	assert( s6.myCapacity == 1 );
	cout << " 3 " << flush;
	// non-minimal non-empty stack to empty stack, different capacities
	Stack<unsigned> s7(3);
	s7.push(11);
	s7.push(22);
	s7.push(33);
	Stack<unsigned> s8(2);
	s8 = s7;
	assert( s8.myArray != s7.myArray );
	assert( s8.myCapacity == s7.myCapacity );
	assert( s8.mySize == s7.mySize );
	assert( s8.pop() == 33 );
	assert( s8.pop() == 22 );
	assert( s8.pop() == 11 );
	assert( s7.peekTop() == 33 );
	cout << " 4 " << flush;
	// non-minimal, empty stack to non-empty stack, different capacities
	Stack<unsigned> s9(2);
	Stack<unsigned> s10(3);
	s10.push(11);
	s10.push(22);
	s10.push(33);
	s10 = s9;
	assert( s10.isEmpty() );
	assert( s10.myArray != s9.myArray );
	assert( s10.myCapacity == s10.myCapacity );
	cout << " 5 " << flush;
	// self-assignment, minimal size
	Stack<unsigned> s11(1);
	s11.push(11);
	s11 = s11;
	assert( s11.isFull() );
	assert( !s11.isEmpty() );
	cout << " 6 " << flush;
	// chaining
	Stack<unsigned> s12(2);
	s12.push(11);
	s12.push(22);
	Stack<unsigned> s13(1);
	Stack<unsigned> s14(1);
	s14 = s13 = s12;
	assert( s14.isFull() );
	assert( s14.myArray != s13.myArray );
	assert( s14.myArray != s12.myArray );
	assert( s14.pop() == 22 );
	assert( s14.pop() == 11 );
	assert( s14.isEmpty() );
	cout << " 7 " << flush;
	// self-assignment, non-minimal size
	s13 = s13;
	assert( !s13.isEmpty() );
	assert( s13.isFull() );
	assert( s13.pop() == 22 );
	assert( s13.pop() == 11 );
	assert( s13.isEmpty() );
	cout << " 8 " << flush;
	cout << "Passed!" << endl;
}

void StackTester::testDestructor() {
	cout << "- Testing destructor..." << flush;
	// minimal, empty
	Stack<unsigned> s1(1);
	s1.~Stack();
	assert( s1.isEmpty() );
	assert( s1.myArray == NULL );
	assert( s1.myCapacity == 0 );
	cout << " 1 " << flush;
	// minimal, non-empty
	Stack<unsigned> s2(1);
	s2.push(11);
	s2.~Stack();
	assert( s2.isEmpty() );
	assert( s2.myArray == NULL );
	assert( s2.myCapacity == 0 );
	cout << " 2 " << flush;
	// non-minimal, empty
	Stack<unsigned> s3(3);
	s3.~Stack();
	assert( s3.isEmpty() );
	assert( s3.myArray == NULL );
	assert( s3.myCapacity == 0 );
	cout << " 3 " << flush;
	// non-minimal, non-empty
	Stack<unsigned> s4(3);
	s4.push(11);
	s4.push(22);
	s4.push(33);
	s4.~Stack();
	assert( s4.isEmpty() );
	assert( s4.myArray == NULL );
	assert( s4.myCapacity == 0 );
	cout << " 4 " << flush;
	cout << " Passed!" << endl;
}

void StackTester::testGetCapacity() {
	cout << "- Testing getCapacity()... " << flush;

	// check capacity
	Stack<unsigned> s0(0);
	assert( s0.getCapacity() == 0 );
	cout << " 0 " << flush;

	// check capacity after 1 push
	Stack<unsigned> s1(1);
	s1.push(11);
	assert( s1.getCapacity() == 1 );
	s1.pop();
	cout << " 1 " << flush;

	// check capacity after 2 push
	Stack<unsigned> s2(2);
	s2.push(11);
	s2.push(22);
	assert( s2.getCapacity() == 2 );
	s2.pop();
	s2.pop();
	cout << " 2 " << flush;

	// check capacity after 3 push
	Stack<unsigned> s3(3);
	s3.push(11);
	s3.push(22);
	s3.push(33);
	assert( s3.getCapacity() == 3 );
	s3.pop();
	s3.pop();
	s3.pop();
	cout << " 3 " << flush;

	cout << " Passed! " << endl;
}

void StackTester::testGetSize() {
	cout << "- Testing getSize()... " << flush;

	// check size
	Stack<unsigned> s0(0);
	assert( s0.getSize() == 0 );
	cout << " 0 " << flush;

	// push 1 check size each pop()
	Stack<unsigned> s1(1);
	s1.push(11);
	assert( s1.getSize() == 1 );
	s1.pop();
	assert( s1.getSize() == 0 );
	cout << " 1 " << flush;

	// push 2 check size each pop()
	Stack<unsigned> s2(2);
	s2.push(11);
	s2.push(22);
	assert( s2.getSize() == 2 );
	s2.pop();
	assert( s2.getSize() == 1 );
	s2.pop();
	assert( s2.getSize() == 0 );
	cout << " 2 " << flush;

	// push 3 check size each pop()
	Stack<unsigned> s3(3);
	s3.push(11);
	s3.push(22);
	s3.push(33);
	assert( s3.getSize() == 3 );
	s3.pop();
	assert( s3.getSize() == 2 );
	s3.pop();
	assert( s3.getSize() == 1 );
	s3.pop();
	assert( s3.getSize() == 0 );
	cout << " 3 " << flush;

	cout << " Passed! " << endl;
}

void StackTester::testSetCapacity() {
	cout << "- Testing setCapacity()... " << flush;

	// capacity increase from null
	Stack<unsigned> s0(0);
	assert( s0.getCapacity() == 0 );
	s0.setCapacity(1);
	assert( s0.getCapacity() == 1 );
	cout << " 0 " << flush;

	// capacity increase from non-null
	Stack<unsigned> s2(1);
	assert( s2.getCapacity() == 1 );
	s2.setCapacity(2);
	assert( s2.getCapacity() == 2 );
	cout << " 1 " << flush;

	// capacity no change
	Stack<unsigned> s3(74);
	assert( s3.getCapacity() == 74 );
	s3.setCapacity(74);
	assert( s3.getCapacity() == 74 );
	cout << " 2 " << flush;

	// capacity decrease from non-null
	Stack<unsigned> s4(1);
	try {
		s4.setCapacity(0);
		cerr << "\ns4.setCapacity() invalid capacity worked!";
		exit(1);
	} catch (const StackException& se) {
		cout << " 3 " << flush;
	}

	cout << " Passed! " << endl;
}









/* StackException.h models exceptions in stack operations.
 * Joel Adams, for CS 112 at Calvin University.
 * Student Name:
 * Date:
 */

#ifndef STACK_EXCEPTION
#define STACK_EXCEPTION

#include <iostream>
using namespace std;

 
class StackException {
public:
   StackException(const string& whereThrown,
                  const string& message) { 
       myLocation = whereThrown; 
       myMessage = message; 
   }

   string asString() const {
       return "*** StackException in " +
               myLocation + ": " + myMessage; 
   }

private:
   string myLocation;
   string myMessage;
};  // StackException


/* Function to allow a StackException (or a subclass) to be displayed
 * via an ostream.
 * Parameters: out, an ostream;
 *             se, a StackException.
 * Postcondition: the string representation of se has been inserted
 * into out
 *             && return-value == out.
 */
inline ostream& operator<<(ostream& out, const StackException& se) {
      out << se.asString();
      return out;
}

#endif









/*
 * PalindromeDetector.h
 *
 *  Created on: Nov 12, 2019
 *      Author: mjs96
 */

#include <string>
#include <fstream>
#include <iostream>
#include <cassert>
#include <string>
#include "Stack.h"
#include "ArrayQueue.h"
using namespace std;

#ifndef PALINDROME_H_
#define PALINDROME_H_

class Palindrome {
public:
	Palindrome(string fileNameIn, string fileNameOut);
	void detectPalindromes();
	bool isPalindrome(const string& str) const;
private:
	string fileIn = "";
	string fileOut = "";
	friend class PalindromeTester;
};

#endif /* PALINDROME_H_ */
/*
 * Palindrome.cpp
 *
 *  Created on: Nov 12, 2019
 *      Author: mjs96
 */

#include "Stack.h"
#include "Palindrome.h"

/* Palindrome Constructor
 * @param:			fileNameIn, a string
 * @param:			fileNameOut, a string
 * Precondition:	fileIn and fileOut are empty strings
 * Postcondition:	fileIn holds value of fileNameIn
 * Postcondition:	fileOut holds value of fileNameOut
 * AUTHORED BY:		Michael Sisko
 */
Palindrome::Palindrome( string fileNameIn, string fileNameOut  ) {
	fileIn = fileNameIn;
	fileOut = fileNameOut;
}

/* Palindrome Detector
 * @param:			none
 * Precondition:	none
 * Postcondition:	fileIn has been evaluated
 * Postcondition:	fileOut has been written to
 * AUTHORED BY:		Michael Sisko
 */
void Palindrome::detectPalindromes() {
	ifstream fin( fileIn.c_str() );
	assert( fin.is_open() );
	ofstream fout( fileOut.c_str() );
	assert( fout.is_open() );
	string currLine;
	while ( fin.good() ) {
		getline(fin,currLine);
		fout << currLine;
		if ( isPalindrome(currLine) ) {
			fout << " ***";
		}
		fout << '\n';
	}
	fin.close();
	fout.close();
}

/* Bool isPalindrome()
 * @param:			str, a string
 * Precondition:	str holds a line of fileIn
 * Postcondition:	str has been evaluated
 * Postcondition:	returns true or false
 * AUTHORED BY:		Michael Sisko
 */
bool Palindrome::isPalindrome(const string& str) const {
	if ( str.length() == 0 ) {
		return false;
	}
	Stack<char> s0(1);
	ArrayQueue<char> aq0(1);
	for (unsigned i=0; i < str.length(); ++i) {
		if ( isalpha(str[i]) ) {
			try {
				s0.push( tolower(str[i]) );
				aq0.append( tolower(str[i]) );
			} catch (StackException& se) {
				s0.setCapacity(2*s0.getCapacity());
				aq0.setCapacity(2*aq0.getCapacity());
				s0.push( tolower( str[i] ) );
				aq0.append( tolower( str[i] ) );
			}
		}
	}
	while ( !s0.isEmpty() ) {
		char s0char = s0.pop();
		char aq0char = aq0.remove();
		if ( s0char != aq0char ) {
			return false;
		}
	}
	return true;
}

/*
 * PalindromeTester.h
 *
 *  Created on: Nov 12, 2019
 *      Author: mjs96
 */

#ifndef PALINDROMETESTER_H_
#define PALINDROMETESTER_H_

#include <cassert>
#include "Palindrome.h"

class PalindromeTester {
public:
	void runTests();
	void testPalindrome();
};

#endif /* PALINDROMETESTER_H_ */
/*
 * PalindromeDetectorTester.cpp
 *
 *  Created on: Nov 12, 2019
 *      Author: mjs96
 */

#include "Palindrome.h"
#include "PalindromeTester.h"

void PalindromeTester::runTests() {
	cout << "Testing class Palindrome..." << endl;
	testPalindrome();
	cout << "All tests passed!\n" << endl;
}

void PalindromeTester::testPalindrome() {
	cout << "- testing detectPalindromes... " << flush;

	Palindrome p0("pTestIn.txt","pTestOut.txt");
	p0.detectPalindromes();
	string outLine;
	ifstream fin( "pTestOut.txt" );
	cout << " 0 " << flush;

	// empty case
	getline(fin,outLine);
	assert( outLine == "");
	cout << " 1 " << flush;

	// actual palindromes
	getline(fin,outLine);
	assert( outLine == "Madam, I'm Adam. ***");
	cout << " 2a " << flush;
	getline(fin,outLine);
	assert( outLine == "A man, a plan, a canal, Panama! ***");
	cout << " 2b " << flush;
	getline(fin,outLine);
	assert( outLine == "Never Odd Or Even! ***");
	cout << " 2c " << flush;

	// non-palindromes
	getline(fin,outLine);
	assert( outLine == "King, are you glad you are king?");
	cout << " 3a " << flush;
	getline(fin,outLine);
	assert( outLine == "Night after night");
	cout << " 3b " << flush;
	getline(fin,outLine);
	assert( outLine == "Fall leaves after leaves fall");
	cout << " 3c " << flush;
	fin.close();

	cout << " Passed!" << endl;
}









/* tester.cpp drives the testing of the Queue classes.
 * Joel Adams, for CS 112 at Calvin University.
 */

 #include "ArrayQueueTester.h"
 #include "PalindromeTester.h"
 
 int main() {
 	ArrayQueueTester aqt;
 	aqt.runTests();
 	PalindromeTester pdt;
 	pdt.runTests();

 	string fileNameIn;
	string fileNameOut;
 	cout << "Welcome to the Palindrome tester!" << endl;

 	cout << "Please enter an input file: " << flush;
 	cin >> fileNameIn;
 	cout << "Please enter an output file: " << flush;
 	cin >> fileNameOut;

 	Palindrome p0(fileNameIn, fileNameOut);
 	p0.detectPalindromes();

 	cout << "Operation Complete! please see: " << fileNameOut;
 	cout << " for the results!" << endl;
 }










Madam, I'm Adam.
A man, a plan, a canal, Panama!
Never Odd Or Even!
King, are you glad you are king?
Night after night
Fall leaves after leaves fall
Madam, I'm Adam. ***
A man, a plan, a canal, Panama! ***
Never Odd Or Even! ***
King, are you glad you are king?
Night after night
Fall leaves after leaves fall
Drawn Onward

by Felicia Lamport
extended by Joel Adams        

The learned men of Rome
could turn a palindrome
but they were not the first.

For Adam, says the myth,
began conversing with
a sentence that reversed:
"Madam, I'm Adam"
seemed
a phrase to be esteemed
the moment it was popped.
But that was not to be
- his lady instantly said
"Eve"
which left it topped.

Eve damned Eden; mad Eve
bore two sons,
as goes the fable,
the first named
Cain, a maniac,
who slew his brother Abel.
He lived as a devil, eh?
Violence begat violence, until today
we panic in a pew,
the cycle turns anew
and descendents of Ned Ludd
-- dumb mobs -- bomb mud.

Asked his favorite dessert, Archimedes said,
"I prefer PI"

And Napoleon, post-Josephine, mused,
"Able was I, ere I saw Elba,"
as he met his Waterloo, confused.

Anonymous, the most
prolific bard, can boast
of being host
to these:

"Was it a car or a cat I saw ?"

"Some men interpret nine memos."

"Lewd did I live, evil I did dwel."

"Sex at noon taxes."

"A man, a plan, a canal, Panama!"

"Stop, murder us not, tonsured rumpots!"

"Straw? No, too stupid a fad. I put soot on warts."

"Doc, note: I dissent. A fast never prevents a fatness. I diet on cod."

"Kay, a red nude, peeped under a yak."

and that marvel of marvels:

"Sit on a potato pan, Otis!"

What span, what palindromic bliss!

I've wrung the alphabet
repeatedly to get
a Janus-phrase so spry
at backwards somersaults.
But as each hope turns false,
in words, alas, drown I.

]0;mjs96@gold28: ~/cs112/project08[01;32mmjs96@gold28[00m:[01;34m~/cs112/project08[00m$ [Kcd Debug
]0;mjs96@gold28: ~/cs112/project08/Debug[01;32mmjs96@gold28[00m:[01;34m~/cs112/project08/Debug[00m$ ls
ArrayQueue.d        makefile      PalindromeTester.d  StackTester.d  tester.o
ArrayQueue.o        objects.mk    PalindromeTester.o  StackTester.o
ArrayQueueTester.d  Palindrome.d  [0m[01;32mproject08[0m           subdir.mk
ArrayQueueTester.o  Palindrome.o  sources.mk          tester.d
]0;mjs96@gold28: ~/cs112/project08/Debug[01;32mmjs96@gold28[00m:[01;34m~/cs112/project08/Debug[00m$ make all
make: Nothing to be done for 'all'.
]0;mjs96@gold28: ~/cs112/project08/Debug[01;32mmjs96@gold28[00m:[01;34m~/cs112/project08/Debug[00m$ cd ..
]0;mjs96@gold28: ~/cs112/project08[01;32mmjs96@gold28[00m:[01;34m~/cs112/project08[00m$ ./Debug/project08
Testing class ArrayQueue...
- testing constructor...  1  2  Passed!
- testing append(), getFirst(), getLast() ...  0a  0b  1  2  3  4  5 Passed, but wrap-around not tested...
- testing remove()...  0  1  2  3  4a  4b  4c  4d  5  6a  6b  6c Passed!
- testing copy constructor...  1  2  3 Passed!
- testing assignment...  1  2  3  4  5  6  7 Passed!
- testing setCapacity()...  0a  0b  0c  1a  1b  1c  2  3  4  5  Passed!
All tests passed!

Testing class Palindrome...
- testing detectPalindromes...  0  1  2a  2b  2c  3a  3b  3c  Passed!
All tests passed!

Welcome to the Palindrome tester!
Please enter an input file: drawnOnward.txt
Please enter an output file: drawnOnwardOut.txt
Operation Complete! please see: drawnOnwardOut.txt for the results!
]0;mjs96@gold28: ~/cs112/project08[01;32mmjs96@gold28[00m:[01;34m~/cs112/project08[00m$ cat drawnOnwardOut.tct  xt
Drawn Onward ***

by Felicia Lamport
extended by Joel Adams        

The learned men of Rome
could turn a palindrome
but they were not the first.

For Adam, says the myth,
began conversing with
a sentence that reversed:
"Madam, I'm Adam" ***
seemed
a phrase to be esteemed
the moment it was popped.
But that was not to be
- his lady instantly said
"Eve" ***
which left it topped.

Eve damned Eden; mad Eve ***
bore two sons,
as goes the fable,
the first named
Cain, a maniac, ***
who slew his brother Abel.
He lived as a devil, eh? ***
Violence begat violence, until today
we panic in a pew, ***
the cycle turns anew
and descendents of Ned Ludd
-- dumb mobs -- bomb mud. ***

Asked his favorite dessert, Archimedes said,
"I prefer PI" ***

And Napoleon, post-Josephine, mused,
"Able was I, ere I saw Elba," ***
as he met his Waterloo, confused.

Anonymous, the most
prolific bard, can boast
of being host
to these:

"Was it a car or a cat I saw ?" ***

"Some men interpret nine memos." ***

"Lewd did I live, evil I did dwel." ***

"Sex at noon taxes." ***

"A man, a plan, a canal, Panama!" ***

"Stop, murder us not, tonsured rumpots!" ***

"Straw? No, too stupid a fad. I put soot on warts." ***

"Doc, note: I dissent. A fast never prevents a fatness. I diet on cod." ***

"Kay, a red nude, peeped under a yak." ***

and that marvel of marvels:

"Sit on a potato pan, Otis!" ***

What span, what palindromic bliss!

I've wrung the alphabet
repeatedly to get
a Janus-phrase so spry
at backwards somersaults.
But as each hope turns false,
in words, alas, drown I. ***


]0;mjs96@gold28: ~/cs112/project08[01;32mmjs96@gold28[00m:[01;34m~/cs112/project08[00m$ exit

Script done on 2019-11-12 23:33:08-0500
